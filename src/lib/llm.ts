import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import { HumanMessage, SystemMessage } from "@langchain/core/messages";

// Initialize Google GenAI client
const genai = new ChatGoogleGenerativeAI({
  apiKey: process.env.GOOGLE_API_KEY || "",
  // Use a more specific and current model name to avoid 404 errors.
  model: "gemini-1.5-flash-latest",
});

// Type for the function response
interface SQLResponse {
  sql: string;
  explanation: string;
  error?: string;
}

/**
 * Generate SQL query from natural language question using Gemini
 */
export async function generateSQLFromQuestion(
  question: string,
  schema: any[],
  dialect: string = "postgresql"
): Promise<SQLResponse> {
  try {
    if (!process.env.GOOGLE_API_KEY) {
      return {
        sql: "",
        explanation: "",
        error:
          "Google API key is not configured. Set GOOGLE_API_KEY in your environment to enable SQL generation.",
      };
    }
    // Format schema information for the prompt
    const schemaInfo = formatSchemaForPrompt(schema);

    // Create the system prompt
    const systemPrompt = `You are an expert SQL translator. Convert the user's natural language question into a precise ${dialect} SQL query.

Database Schema:
${schemaInfo}

Rules:
1. Return ONLY the SQL query, no explanations or additional text
2. Use proper SQL syntax for ${dialect}
3. Use appropriate JOINs if multiple tables are involved
4. Include relevant WHERE clauses for filtering
5. Use appropriate aggregate functions (COUNT, SUM, AVG, etc.) when needed
6. Always use parameterized queries (don't hardcode values)
7. Return the query in a clean, formatted way`;

    // Make the API call to Google Gemini
    // Using 'as any' as a workaround for potential type definition issues in older library versions.
    const response = await genai
      .bind({
        temperature: 0.1,
        maxOutputTokens: 500,
      } as any)
      .invoke([new SystemMessage(systemPrompt), new HumanMessage(question)]);

    const generatedSQL = response.content.toString().trim();

    if (!generatedSQL) {
      throw new Error("No SQL generated by the AI");
    }

    // Clean up the SQL (remove markdown code blocks if present)
    const cleanSQL = generatedSQL
      .replace(/```sql\n?/g, "")
      .replace(/```\n?/g, "")
      .trim();

    return {
      sql: cleanSQL,
      explanation: `Generated SQL for: "${question}"`,
    };
  } catch (error: any) {
    console.error("Error generating SQL:", error);
    const msg = error?.message || "Unknown error";
    // Simplified error handling for Gemini
    if (/api key/i.test(msg)) {
      return {
        sql: "",
        explanation: "",
        error:
          "Google API key is invalid or missing. Please check your GOOGLE_API_KEY.",
      };
    }
    if (/quota/i.test(msg)) {
      return {
        sql: "",
        explanation: "The SQL generator has exceeded its quota.",
        error:
          "Google API quota limit reached. Please check your billing or try again later.",
      };
    }
    return {
      sql: "",
      explanation: "",
      error: `Failed to generate SQL: ${msg}`,
    };
  }
}

/**
 * Format database schema information for the AI prompt
 */
function formatSchemaForPrompt(schema: any[]): string {
  if (!schema || schema.length === 0) {
    return "No schema information available";
  }

  // Group by table name
  const tables: { [key: string]: any[] } = {};
  schema.forEach((column) => {
    if (!tables[column.table_name]) {
      tables[column.table_name] = [];
    }
    tables[column.table_name].push(column);
  });

  // Format each table
  let result = "";
  for (const [tableName, columns] of Object.entries(tables)) {
    result += `Table: ${tableName}\n`;
    columns.forEach((col) => {
      result += `  - ${col.column_name} (${col.data_type})${
        col.is_nullable === "YES" ? " [nullable]" : ""
      }\n`;
    });
    result += "\n";
  }

  return result;
}

/**
 * Validate if a generated SQL query is safe to execute
 */
export function validateSQL(sql: string): { valid: boolean; error?: string } {
  const lowerSQL = sql.toLowerCase();

  // Check for dangerous operations
  const dangerousPatterns = [
    /drop\s+table/i,
    /delete\s+from/i,
    /update\s+.+\s+set/i,
    /insert\s+into/i,
    /alter\s+table/i,
    /truncate\s+table/i,
    /create\s+table/i,
    /grant\s+/i,
    /revoke\s+/i,
    /;\s*$/m, // Multiple statements
  ];

  for (const pattern of dangerousPatterns) {
    if (pattern.test(sql)) {
      return {
        valid: false,
        error: `Query contains potentially dangerous operation: ${pattern.toString()}`,
      };
    }
  }

  // Ensure it's a SELECT query for safety
  if (!lowerSQL.trim().startsWith("select")) {
    return {
      valid: false,
      error: "Only SELECT queries are allowed for safety",
    };
  }

  return { valid: true };
}

/**
 * Explain SQL query in natural language using Gemini
 */
export async function explainSQL(sql: string): Promise<string> {
  try {
    const systemPrompt =
      "You are a data analyst. Explain what the following SQL query does in simple, natural language. Keep it concise (1-2 sentences).";

    // Using 'as any' as a workaround for potential type definition issues in older library versions.
    const response = await genai
      .bind({
        temperature: 0.3,
        maxOutputTokens: 100,
      } as any)
      .invoke([new SystemMessage(systemPrompt), new HumanMessage(sql)]);

    return (
      response.content.toString().trim() || "Unable to generate explanation"
    );
  } catch (error) {
    console.error("Error explaining SQL:", error);
    return "Failed to generate explanation";
  }
}

/**
 * Generate Python script from SQL query using Gemini
 */
export async function generatePythonFromSQL(
  datasetId: string,
  sql: string
): Promise<string> {
  try {
    const systemPrompt = `You are a data engineer. Write a concise Python 3 script using sqlite3 and pandas to run the given SQL on a local database file named ai_copilot.db. The script should include necessary imports and print the first few rows of the result.`;

    const userPrompt = `Table: ${datasetId}\nSQL:\n${sql}`;

    const response = await genai
      .bind({
        temperature: 0.2,
        maxOutputTokens: 400,
      } as any)
      .invoke([new SystemMessage(systemPrompt), new HumanMessage(userPrompt)]);

    let pythonCode = response.content.toString().trim();

    // Clean up markdown code blocks if present
    if (pythonCode.startsWith("```") && pythonCode.endsWith("```")) {
      pythonCode = pythonCode
        .replace(/^```[a-zA-Z]*\n?/, "")
        .replace(/```\n?$/, "")
        .trim();
    }

    return pythonCode;
  } catch (error) {
    console.error("Error generating Python script:", error);
    return ""; // Return empty string on failure
  }
}

