// /src/lib/llm.ts
import OpenAI from 'openai';

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || '',
});

// Type for the function response
interface SQLResponse {
  sql: string;
  explanation: string;
  error?: string;
}

/**
 * Generate SQL query from natural language question
 */
export async function generateSQLFromQuestion(
  question: string, 
  schema: any[], 
  dialect: string = 'postgresql'
): Promise<SQLResponse> {
  try {
    // Format schema information for the prompt
    const schemaInfo = formatSchemaForPrompt(schema);
    
    // Create the system prompt
    const systemPrompt = `You are an expert SQL translator. Convert the user's natural language question into a precise ${dialect} SQL query.

Database Schema:
${schemaInfo}

Rules:
1. Return ONLY the SQL query, no explanations or additional text
2. Use proper SQL syntax for ${dialect}
3. Use appropriate JOINs if multiple tables are involved
4. Include relevant WHERE clauses for filtering
5. Use appropriate aggregate functions (COUNT, SUM, AVG, etc.) when needed
6. Always use parameterized queries (don't hardcode values)
7. Return the query in a clean, formatted way`;

    // Make the API call to OpenAI
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo", // or "gpt-4" if you have access
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: question }
      ],
      temperature: 0.1, // Low temperature for more deterministic output
      max_tokens: 500,
    });

    const generatedSQL = completion.choices[0]?.message?.content?.trim();
    
    if (!generatedSQL) {
      throw new Error('No SQL generated by the AI');
    }

    // Clean up the SQL (remove markdown code blocks if present)
    const cleanSQL = generatedSQL.replace(/```sql\n?/g, '').replace(/```\n?/g, '').trim();

    return {
      sql: cleanSQL,
      explanation: `Generated SQL for: "${question}"`
    };

  } catch (error) {
    console.error('Error generating SQL:', error);
    return {
      sql: '',
      explanation: '',
      error: `Failed to generate SQL: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
}

/**
 * Format database schema information for the AI prompt
 */
function formatSchemaForPrompt(schema: any[]): string {
  if (!schema || schema.length === 0) {
    return 'No schema information available';
  }

  // Group by table name
  const tables: { [key: string]: any[] } = {};
  schema.forEach((column) => {
    if (!tables[column.table_name]) {
      tables[column.table_name] = [];
    }
    tables[column.table_name].push(column);
  });

  // Format each table
  let result = '';
  for (const [tableName, columns] of Object.entries(tables)) {
    result += `Table: ${tableName}\n`;
    columns.forEach((col) => {
      result += `  - ${col.column_name} (${col.data_type})${col.is_nullable === 'YES' ? ' [nullable]' : ''}\n`;
    });
    result += '\n';
  }

  return result;
}

/**
 * Validate if a generated SQL query is safe to execute
 */
export function validateSQL(sql: string): { valid: boolean; error?: string } {
  const lowerSQL = sql.toLowerCase();
  
  // Check for dangerous operations
  const dangerousPatterns = [
    /drop\s+table/i,
    /delete\s+from/i,
    /update\s+.+\s+set/i,
    /insert\s+into/i,
    /alter\s+table/i,
    /truncate\s+table/i,
    /create\s+table/i,
    /grant\s+/i,
    /revoke\s+/i,
    /;\s*$/m // Multiple statements
  ];

  for (const pattern of dangerousPatterns) {
    if (pattern.test(sql)) {
      return {
        valid: false,
        error: `Query contains potentially dangerous operation: ${pattern.toString()}`
      };
    }
  }

  // Ensure it's a SELECT query for safety
  if (!lowerSQL.trim().startsWith('select')) {
    return {
      valid: false,
      error: 'Only SELECT queries are allowed for safety'
    };
  }

  return { valid: true };
}

/**
 * Explain SQL query in natural language
 */
export async function explainSQL(sql: string): Promise<string> {
  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { 
          role: "system", 
          content: "You are a data analyst. Explain what the following SQL query does in simple, natural language. Keep it concise (1-2 sentences)." 
        },
        { role: "user", content: sql }
      ],
      temperature: 0.3,
      max_tokens: 100,
    });

    return completion.choices[0]?.message?.content?.trim() || 'Unable to generate explanation';
  } catch (error) {
    console.error('Error explaining SQL:', error);
    return 'Failed to generate explanation';
  }
}

export default openai;